# ------------------------------------------------------------
# Sensor Box (ESPHome) — Organized Layout
# ------------------------------------------------------------
# Index:
#   1) Substitutions
#   2) Core / Project
#   3) OTA / API / Wi-Fi
#   4) Buses & External Components
#   5) UART Buses
#   6) Globals (runtime state)
#   7) Outputs & Switches (Status LED)
#   8) Runtime Logic (Interval timers)
#   9) Numbers (tunable settings)
#  10) Sensors
#  11) Text Sensors (UART parser)
#  12) Binary Sensors
# ------------------------------------------------------------

# ========================
# 1) Substitutions
# ========================
substitutions:
  devicename: "sensor-box"
  update_time: 30s

# ========================
# 2) Core / Project
# ========================
esphome:
  name: ${devicename}
  name_add_mac_suffix: true
  friendly_name: "Sensor Box"

  project:
    name: alphaars.sensor_box 
    version: "1.2.0"   

  # Re-apply restored number values to the LD1125H via UART on boot
  on_boot:
    priority: 800
    then:
      - delay: 1s
      - number.set:
          id: LD1125H_mth1
          value: !lambda 'return id(LD1125H_mth1).state;'
      - number.set:
          id: LD1125H_mth2
          value: !lambda 'return id(LD1125H_mth2).state;'
      - number.set:
          id: LD1125H_mth3
          value: !lambda 'return id(LD1125H_mth3).state;'
      - number.set:
          id: LD1125H_rmax
          value: !lambda 'return id(LD1125H_rmax).state;'
      - number.set:
          id: LD1125H_Clear_Time
          value: !lambda 'return id(LD1125H_Clear_Time).state;'
      - number.set:
          id: LD1125H_Mov_Time
          value: !lambda 'return id(LD1125H_Mov_Time).state;'

dashboard_import:
  package_import_url: github://AlphaArs/sensor-box/sensor-box.yaml@main

esp32:
  board: nodemcu-32s
  framework:
    type: esp-idf

logger:

# ========================
# 3) OTA / API / Wi-Fi
# ========================
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    # omit ssid -> auto uses device name with MAC suffix
    password: !secret ap_password

captive_portal:

# ========================
# 4) Buses & External Components
# ========================
i2c:
  sda: 21
  scl: 22
  scan: true

external_components:
  - source:
      type: git
      url: https://github.com/ssieb/custom_components
    components:
      - serial

# ========================
# 5) UART Buses
# ========================
# UARTs for LD1125H and PMS7003T sensors
uart:
  - id: LD1125H_UART_BUS
    rx_pin: GPIO16
    tx_pin: GPIO17
    baud_rate: 115200
    data_bits: 8
    stop_bits: 1
    parity: NONE
  - id: pms_uart
    rx_pin: GPIO4
    baud_rate: 9600

# ========================
# 6) Globals (runtime state)
# ========================
globals:
  - id: LD1125H_Last_Time
    type: time_t
    restore_value: false
    initial_value: '0'
  - id: LD1125H_Last_Mov_Time
    type: time_t
    restore_value: false
    initial_value: '0'
  - id: LD1125H_Clearence_Status
    type: bool
    restore_value: false
    initial_value: 'false'

# ========================
# 7) Outputs & Switches (Status LED)
# ========================
output:
  - platform: gpio
    id: status_led_output
    pin:
      number: GPIO2
      inverted: false

switch:
  - platform: output
    id: status_led_switch
    name: "Status LED"
    icon: mdi:led-on
    output: status_led_output
    restore_mode: RESTORE_DEFAULT_OFF

# ========================
# 8) Runtime Logic (Interval timers)
# ========================
interval:
  - interval: 1s
    setup_priority: -200
    then:
      lambda: |-
        const float clear_s = id(LD1125H_Clear_Time).state;
        const float idle_s  = id(LD1125H_Idle_Time).state;
        const time_t elapsed = time(NULL) - id(LD1125H_Last_Time);

        if (elapsed > idle_s) {
          // Long idle → show Idle and ensure binaries are off
          if (id(LD1125H_Occupancy).state != "Idle") {
            id(LD1125H_Occupancy).publish_state("Idle");
          }
          if (id(LD1125H_MovOcc_Binary).state == true) id(LD1125H_MovOcc_Binary).publish_state(false);
          if (id(LD1125H_Mov_Binary).state   == true) id(LD1125H_Mov_Binary).publish_state(false);
          id(LD1125H_Clearence_Status) = true;

        } else if (elapsed > clear_s) {
          // Short quiet period → show Clearance
          if ((id(LD1125H_Clearence_Status) == false) || (id(LD1125H_Occupancy).state != "Clearance")) {
            id(LD1125H_Occupancy).publish_state("Clearance");
            id(LD1125H_Clearence_Status) = true;
          }
          if (id(LD1125H_MovOcc_Binary).state == true) id(LD1125H_MovOcc_Binary).publish_state(false);
          if (id(LD1125H_Mov_Binary).state   == true) id(LD1125H_Mov_Binary).publish_state(false);
        }

# ------------------------------------------------------------
# 9) Numbers (tunable settings)
# ------------------------------------------------------------
# 9.1) Idle/Clear/Movement timings
number:
  - platform: template
    id: LD1125H_Idle_Time
    name: "Idle After (s)"
    icon: mdi:sleep
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 60
    min_value: 5
    max_value: 3600
    step: 5

  - platform: template
    id: LD1125H_mth1
    name: "Motion Threshold 1"
    icon: mdi:cogs
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 60.0
    min_value: 10.0
    max_value: 600.0
    step: 5.0
    set_action:
      - uart.write:
          id: LD1125H_UART_BUS
          data: !lambda |-
            std::string s = "mth1=" + str_sprintf("%.0f", x) + "\r\n";
            return std::vector<uint8_t>(s.begin(), s.end());

  - platform: template
    id: LD1125H_mth2
    name: "Motion Threshold 2"
    icon: mdi:cogs
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 30
    min_value: 5
    max_value: 300
    step: 5
    set_action:
      - uart.write:
          id: LD1125H_UART_BUS
          data: !lambda |-
            std::string s = "mth2=" + str_sprintf("%.0f", x) + "\r\n";
            return std::vector<uint8_t>(s.begin(), s.end());

  - platform: template
    id: LD1125H_mth3
    name: "Motion Threshold 3"
    icon: mdi:cogs
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 20
    min_value: 5
    max_value: 200
    step: 5
    set_action:
      - uart.write:
          id: LD1125H_UART_BUS
          data: !lambda |-
            std::string s = "mth3=" + str_sprintf("%.0f", x) + "\r\n";
            return std::vector<uint8_t>(s.begin(), s.end());

  - platform: template
    id: LD1125H_rmax
    name: "Max Range (m)"
    icon: mdi:arrow-expand-horizontal
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 8
    min_value: 0.4
    max_value: 12
    step: 0.1
    set_action:
      - uart.write:
          id: LD1125H_UART_BUS
          data: !lambda |-
            std::string s = "rmax=" + str_sprintf("%.1f", x) + "\r\n";
            return std::vector<uint8_t>(s.begin(), s.end());

  - platform: template
    id: LD1125H_Clear_Time
    name: "Clearance Delay (s)"
    icon: mdi:timer-sand
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5
    min_value: 0.5
    max_value: 20
    step: 0.5

  - platform: template
    id: LD1125H_Mov_Time
    name: "Movement Debounce (s)"
    icon: mdi:timer-outline
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 1
    min_value: 0.5
    max_value: 10
    step: 0.5

# ========================
# 10) Sensors
# ========================
sensor:
  - platform: uptime
    name: "Uptime"

  - platform: template
    id: LD1125H_Distance
    name: "Distance"
    unit_of_measurement: "m"
    accuracy_decimals: 2
    filters:
      - filter_out: 0.0
      - sliding_window_moving_average:
          window_size: 8
          send_every: 2
      - heartbeat: 0.2s

  - platform: bme680
    temperature:
      id: bme_temp
      name: "Temperature"
      device_class: temperature
      state_class: measurement
      unit_of_measurement: "°C"
    pressure:
      name: "Pressure"
    humidity:
      name: "Humidity"
    gas_resistance:
      name: "Gas Resistance"
    address: 0x77
    update_interval: 60s

  - platform: pmsx003
    uart_id: pms_uart
    type: PMS5003T      
    pm_1_0:
      name: "PM1.0"
    pm_2_5:
      name: "PM2.5"
    pm_10_0:
      name: "PM10"

  - platform: bh1750
    name: "Illuminance"
    update_interval: 60s

  - platform: sgp30
    update_interval: 60s
    eco2:
      name: "eCO2"
    tvoc:
      name: "TVOC"

  - platform: adc
    pin: GPIO34
    name: "MICS5524 (V)"
    update_interval: 10s
    filters:
      - multiply: 3.3

# ========================
# 11) Text Sensors (UART parser)
# ========================
text_sensor:
  - platform: serial
    uart_id: LD1125H_UART_BUS
    id: LD1125H_UART_Text
    name: "LD1125H Raw"
    icon: mdi:format-text
    internal: true
    on_value:
      lambda: |-
        const std::string &s = id(LD1125H_UART_Text).state;
        const float d = atof(s.substr(9).c_str());
        const float MIN_VALID_DIST = 0.05f; // ignore idle/zero

        if (s.rfind("occ", 0) == 0) {
          if (d >= MIN_VALID_DIST) {
            id(LD1125H_Distance).publish_state(d);
          }
          if ((time(NULL) - id(LD1125H_Last_Mov_Time)) > id(LD1125H_Mov_Time).state) {
            id(LD1125H_Occupancy).publish_state("Occupancy");
            if (!id(LD1125H_MovOcc_Binary).state) id(LD1125H_MovOcc_Binary).publish_state(true);
            if (id(LD1125H_Mov_Binary).state)     id(LD1125H_Mov_Binary).publish_state(false);
          }
          if (!id(LD1125H_MovOcc_Binary).state) id(LD1125H_MovOcc_Binary).publish_state(true);
          id(LD1125H_Last_Time) = time(NULL);
          if (id(LD1125H_Clearence_Status) == true) id(LD1125H_Clearence_Status) = false;

        } else if (s.rfind("mov", 0) == 0) {
          if (d < MIN_VALID_DIST) {
          
            // update "last seen" so clearance/idle timers work, but don't flag movement
            id(LD1125H_Last_Time) = time(NULL);
            return;
          }
          id(LD1125H_Distance).publish_state(d);
          id(LD1125H_Occupancy).publish_state("Movement");
          if (!id(LD1125H_MovOcc_Binary).state) id(LD1125H_MovOcc_Binary).publish_state(true);
          if (!id(LD1125H_Mov_Binary).state)    id(LD1125H_Mov_Binary).publish_state(true);
          id(LD1125H_Last_Mov_Time) = time(NULL);
          id(LD1125H_Last_Time) = time(NULL);
          if (id(LD1125H_Clearence_Status) == true) id(LD1125H_Clearence_Status) = false;
        }

  - platform: template
    id: LD1125H_Occupancy
    name: "Occupancy"
    icon: mdi:motion-sensor

# ========================
# 12) Binary Sensors
# ========================
binary_sensor:
  - platform: status
    name: "Status"

  - platform: template
    id: LD1125H_MovOcc_Binary
    name: "Occupancy or Movement"
    device_class: occupancy

  - platform: template
    id: LD1125H_Mov_Binary
    name: "Movement"
    device_class: motion


